#### 内存管理\垃圾回收
```golang
以申请size为n的内存为例，分配步骤如下：
    获取当前线程的私有缓存mcache
    根据size计算出适合的class的ID
    从mcache的alloc[class]链表中查询可用的span
    如果mcache没有可用的span则从mcentral申请一个新的span加入mcache中
    如果mcentral中也没有可用的span则从mheap中申请一个新的span加入mcentral
    从该span中获取到空闲对象地址并返回

概览
    Golang程序启动时申请一大块内存，并划分成spans、bitmap、arena区域
    arena区域按页划分成一个个小块
    span管理一个或多个页
    mcentral管理多个span供线程申请使用
    mcache作为线程私有资源，资源来源于mcentral

    type mheap struct {
    lock      mutex

    spans []*mspan

    bitmap        uintptr     //指向bitmap首地址，bitmap是从高地址向低地址增长的

    arena_start uintptr        //指示arena区首地址
    arena_used  uintptr        //指示arena区已使用地址位置

    central [67*2]struct {
        mcentral mcentral
        pad      [sys.CacheLineSize - unsafe.Sizeof(mcentral{})%sys.CacheLineSize]byte
    }
}

mheap -- mcentrl -- mcache

小对象(小于等于32k)，走的是三级缓存的内存管理机制(先从mcache申请，没有再从mcentral申请，最后还不够放入mheap中)，如果是大对象，会直接会向堆申请内存空间(mheap)
```

* 微服务架构了解
* 项目上限流程
* 如何查找内存泄露
https://blog.csdn.net/m0_57116438/article/details/123799150
pprof
建议;加函数退出出口,特别是会创建多个的会阻塞的goroutine
https://blog.csdn.net/zuiyijiangnan/article/details/112764818
主要是由于channel
0. top不能反映内存占用,因为go申请的内存,在使用后不会立即归还
1. 不能由消费者关闭channel,要由生产者写完数据后关闭
2. 可以利用关闭channel来广播取消动作

* 索引优化，SQL优化
* goroutine嵌套异常处理
* chan的数据结构
* map底层结构
hmap{
    count
    B
    *buckets
}

bmap{
    tophash[8]
    *datas
    *overflow
}

扩容
增量扩容:负载因子>6.5后,新增时发生扩容,渐进式扩容,每次操作map时迁移两个key
等量扩容:overflows过多,数据松散时发生等量扩容,数据重组


红黑树维护成本比平衡二叉树低，性能上也能大致做到 O(logn)，且比较稳定，可以应付最差的情况

ldflags参数去掉符号表和调试信息降低二进制包的体积
go build -ldflags="-s -w" -o server main.go

为什么TCP连接的时候是3次，关闭的时候却是4次？
等待数据完全传输完才回fin包
因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。

等待2msl
1. 由于网络层传输不稳定原因,需要等待另一方正确ACK了才能关闭
2. 确保网络中数据传输完毕没有遗留,下个连接如果端口一样会错乱


http和websocket区别

* map key的查找过程
https://golang.design/go-questions/map/principal/
假定 B = 5，所以 bucket 总数就是 2^5 = 32。首先计算出待查找 key 的哈希，使用低 5 位 00110，找到对应的 6 号 bucket，使用高 8 位 10010111，对应十进制 151，在 6 号 bucket 中寻找 tophash 值（HOB hash）为 151 的 key，找到了 2 号槽位，这样整个查找过程就结束了。




